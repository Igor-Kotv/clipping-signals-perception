{"version":3,"file":"static/js/871.f9ad428f.chunk.js","mappings":"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","sources":["../node_modules/node-wav/index.js"],"sourcesContent":["/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n'use strict';\n\nconst data_decoders = {\n  pcm8: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++] - 128;\n        output[ch][i] = data < 0 ? data / 128 : data / 127;\n      }\n    }\n  },\n  pcm16: (buffer, offset, output, channels, samples) => {\n    let input = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 32768 : data / 32767;\n      }\n    }\n  },\n  pcm24: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let x0 = input[pos++];\n        let x1 = input[pos++];\n        let x2 = input[pos++];\n        let xx = (x0 + (x1 << 8) + (x2 << 16));\n        let data = xx > 0x800000 ? xx - 0x1000000 : xx;\n        output[ch][i] = data < 0 ? data / 8388608 : data / 8388607;\n      }\n    }\n  },\n  pcm32: (buffer, offset, output, channels, samples) => {\n    let input = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 2147483648 : data / 2147483647;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, output, channels, samples) => {\n    let input = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch)\n        output[ch][i] = input[pos++];\n    }\n  },\n  pcm64f: (buffer, offset, output, channels, samples) => {\n    let input = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch)\n        output[ch][i] = input[pos++];\n    }\n  },\n};\n\nconst data_encoders = {\n  pcm8: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v * 0.5 + 0.5) * 255) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm16: (buffer, offset, input, channels, samples) => {\n    let output = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? v * 32768 : v * 32767) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm24: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? 0x1000000 + v * 8388608 : v * 8388607) | 0;\n        output[pos++] = (v >> 0) & 0xff;\n        output[pos++] = (v >> 8) & 0xff;\n        output[pos++] = (v >> 16) & 0xff;\n      }\n    }\n  },\n  pcm32: (buffer, offset, input, channels, samples) => {\n    let output = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? v * 2147483648 : v * 2147483647) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, input, channels, samples) => {\n    let output = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));        \n        output[pos++] = v;\n      }\n    }\n  },\n  pcm64f: (buffer, offset, input, channels, samples) => {\n    let output = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));        \n        output[pos++] = v;\n      }\n    }\n  },\n};\n\nfunction lookup(table, bitDepth, floatingPoint) {\n  let name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\n  let fn = table[name];\n  if (!fn)\n    throw new TypeError('Unsupported data format: ' + name);\n  return fn;\n}\n\nfunction decode(buffer) {\n  let pos = 0, end = 0;\n  if (buffer.buffer) {\n    // If we are handed a typed array or a buffer, then we have to consider the\n    // offset and length into the underlying array buffer.\n    pos = buffer.byteOffset;\n    end = buffer.length;\n    buffer = buffer.buffer;\n  } else {\n    // If we are handed a straight up array buffer, start at offset 0 and use\n    // the full length of the buffer.\n    pos = 0;\n    end = buffer.byteLength;\n  }\n\n  let v = new DataView(buffer);\n\n  function u8() {\n    let x = v.getUint8(pos);\n    pos++;\n    return x;\n  }\n\n  function u16() {\n    let x = v.getUint16(pos, true);\n    pos += 2;\n    return x;\n  }\n\n  function u32() {\n    let x = v.getUint32(pos, true);\n    pos += 4;\n    return x;\n  }\n\n  function string(len) {\n    let str = '';\n    for (let i = 0; i < len; ++i)\n      str += String.fromCharCode(u8());\n    return str;\n  }\n\n  if (string(4) !== 'RIFF')\n    throw new TypeError('Invalid WAV file');\n  u32();\n  if (string(4) !== 'WAVE')\n    throw new TypeError('Invalid WAV file');\n\n  let fmt;\n  \n  while (pos < end) {\n    let type = string(4);\n    let size = u32();\n    let next = pos + size;\n    switch (type) {\n    case 'fmt ':\n      let formatId = u16();\n      if (formatId !== 0x0001 && formatId !== 0x0003)\n        throw new TypeError('Unsupported format in WAV file: ' + formatId.toString(16));\n      fmt = {\n        format: 'lpcm',\n        floatingPoint: formatId === 0x0003,\n        channels: u16(),\n        sampleRate: u32(),\n        byteRate: u32(),\n        blockSize: u16(),\n        bitDepth: u16(),\n      };\n      break;\n    case 'data':\n      if (!fmt)\n        throw new TypeError('Missing \"fmt \" chunk.');\n      let samples = Math.floor(size / fmt.blockSize);\n      let channels = fmt.channels;\n      let sampleRate = fmt.sampleRate;\n      let channelData = [];\n      for (let ch = 0; ch < channels; ++ch)\n        channelData[ch] = new Float32Array(samples);\n      lookup(data_decoders, fmt.bitDepth, fmt.floatingPoint)(buffer, pos, channelData, channels, samples);\n      return {\n        sampleRate: sampleRate,\n        channelData: channelData\n      };\n      break;\n    }\n    pos = next;\n  }\n}\n\nfunction encode(channelData, opts) {\n  let sampleRate = opts.sampleRate || 16000;\n  let floatingPoint = !!(opts.float || opts.floatingPoint);\n  let bitDepth = floatingPoint ? 32 : ((opts.bitDepth | 0) || 16);\n  let channels = channelData.length;\n  let samples = channelData[0].length;\n  let buffer = new ArrayBuffer(44 + (samples * channels * (bitDepth >> 3)));\n\n  let v = new DataView(buffer);\n  let pos = 0;\n\n  function u8(x) {\n    v.setUint8(pos++, x);\n  }\n\n  function u16(x) {\n    v.setUint16(pos, x, true);\n    pos += 2;\n  }\n\n  function u32(x) {\n    v.setUint32(pos, x, true);\n    pos += 4;\n  }\n  \n  function string(s) {\n    for (var i = 0; i < s.length; ++i)\n      u8(s.charCodeAt(i));\n  }\n\n  // write header\n  string('RIFF');\n  u32(buffer.byteLength - 8);\n  string('WAVE');\n\n  // write 'fmt ' chunk\n  string('fmt ');\n  u32(16);\n  u16(floatingPoint ? 0x0003 : 0x0001);\n  u16(channels);\n  u32(sampleRate);\n  u32(sampleRate * channels * (bitDepth >> 3));\n  u16(channels * (bitDepth >> 3));\n  u16(bitDepth);\n\n  // write 'data' chunk\n  string('data');\n  u32(buffer.byteLength - 44);\n  lookup(data_encoders, bitDepth, floatingPoint)(buffer, pos, channelData, channels, samples);\n\n  return Buffer(buffer);\n}\n\nmodule.exports = {\n  decode: decode,\n  encode: encode,\n};\n"],"names":["data_decoders","pcm8","buffer","offset","output","channels","samples","input","Uint8Array","pos","i","ch","data","pcm16","Int16Array","pcm24","xx","pcm32","Int32Array","pcm32f","Float32Array","pcm64f","Float64Array","data_encoders","v","Math","max","min","lookup","table","bitDepth","floatingPoint","name","fn","TypeError","module","exports","decode","end","byteOffset","length","byteLength","fmt","DataView","u8","x","getUint8","u16","getUint16","u32","getUint32","string","len","str","String","fromCharCode","type","size","next","formatId","toString","format","sampleRate","byteRate","blockSize","floor","channelData","encode","opts","float","ArrayBuffer","setUint16","setUint32","s","charCodeAt","setUint8","Buffer"],"sourceRoot":""}